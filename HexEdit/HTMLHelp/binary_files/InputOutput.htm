<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Character Sets</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=date content="08 4, 2002 1:06:41 AM">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=1363>
<meta name=layout-width content=1239>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\Hexedit.css">



</head>

<!--(Body)==========================================================-->


<body>

<h2><font style="font-family: Arial;"
			face=Arial>Character Sets</font></h2>

<p>&nbsp;</p>

<p>Traditionally &quot;data processing&quot; consists of input of data 
 from humans, typically via a keyboard, and sooner or later (perhaps after 
 extensive processing) the data is viewed by humans, typically on a screen 
 or printed page. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->To 
 accomplish this, the operating system and even the hardware is designed 
 around a set of symbols. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->So, 
 for example, a keyboard might send a number representing the letter &quot;A&quot; 
 and this would be the same number that is used to draw an &quot;A&quot; 
 on a screen or printer. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 set of symbols and their corresponding values is called a character set. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This sort 
 of interaction is text or character-oriented.</p>

<p>&nbsp;</p>

<p>Computer use has evolved so that a lot of &quot;data&quot; is no longer 
 generated by humans but by machines such as music from CD, images from 
 a digital camera, etc. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Even 
 human interaction has changed so that displays are no longer character-oriented 
 but bitmapped. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Operating 
 systems still need to work with characters but it has become less of the 
 main focus.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">IBM/OEM Characters</p>

<p>&nbsp;</p>

<p>MSDOS (from which Windows evolved) was heavily character oriented since 
 it was designed to run on the IBM PC which originally had just an 80 by 
 25 character-oriented screen display. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 screen could only display 25 rows of 80 characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(Nowadays 
 this display mode is rarely seen except when you first turn on the computer 
 before Windows takes you to a bitmapped display.) <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Each 
 of the characters could only be one of 256 different values (although 
 there were another 8 bits used for attributes such as highlighted, underlined 
 etc). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 advantage of this is that it only required 4 KBytes of video memory. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 shape of each of the 256 characters was determined by the character set 
 ROM (part of the video hardware). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Although 
 clone makers (OEMs) could provide their own set of character shapes they 
 typically did not and hence the IBM set became a defacto standard.</p>

<p>&nbsp;</p>

<p>Although it is referred to in HexEdit as the IBM/OEM character set it 
 is techically not really a character set, more a set of character shapes. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The values 
 from 32 to 126 give shapes corresponding to characters of the ASCII character 
 set, but other values give various graphics characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, the byte value 9 (which is the tab control character in ASCII) 
 displays as a small circle. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In 
 other words in a text file a byte with the value 9 is a tab character 
 but when a byte with value 9 is written to video memory it displays as 
 a small circle - it is up to the operating system to convert a tab character 
 into spaces when a text file is displayed on the screen.</p>

<p>&nbsp;</p>

<p>The extra graphics characters kindly provided by IBM varied from useful 
 things like western European language characters and symbols for line 
 drawing to useless things like happy faces. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->These 
 extra characters were often used in MSDOS programs (particularly games). 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->As Windows 
 is derived from MSDOS it is sometimes useful to be able to use these characters 
 which is why Windows provides a class of &quot;OEM/DOS&quot; fonts (eg, 
 &quot;Terminal&quot;), as opposed to the normal ANSI fonts.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">Character Sets</p>

<p>&nbsp;</p>

<p>One (of many) reasons that an 8-bit byte is popular is that it stores 
 256 values, which is about the right number for storing a set of characters 
 such as the English alphabet, digits, punctuation plus a few other miscellaneous 
 things. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 ASCII and EBCDIC character sets both use one byte per character (actually 
 ASCII only requires 7 of the 8 bits of a byte). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 ANSI character set, discussed below, also requires one byte. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 Unicode requires 2 bytes per character. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Other 
 systems such as DBCS are also discussed below.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">ASCII</p>

<p>&nbsp;</p>

<p>ASCII reserves 32 values (0 to 31) for control characters, 94 characters 
 for upper and lower case letters, digits, punctuation etc, plus character 
 32 is a SPACE, and character 127 is DEL (sort of another control character). 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Notice 
 that ASCII only uses 128 values and can fit into 7 bits. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 top bit of the byte is usually left as zero, but is sometimes used a parity 
 bit during transmission of ASCII data.</p>

<p>&nbsp;</p>

<p>Most ASCII control characters are not important in text files, but a 
 few are very important such as carriage return, line feed, and tab. For 
 example, in MSDOS (and MSWindows) a carriage return followed by a line 
 feed indicates the end of a line of text. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(UNIX 
 and Amiga use a line feed only, and a Mac uses a carriage return.) <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 historical reasons (because CP/M and hence MSDOS 1.0 did not store a file 
 size in the directory) you also sometimes, but rarely nowadays, see an 
 MSDOS file with a Ctrl+Z at the end to signal EOF.</p>

<p>&nbsp;</p>

<p>ASCII has been extended in various ways as discussed later.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">EBCDIC</p>

<p><!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}--></p>

<p>A completely different character set is EBCDIC. IBM invented it for 
 its larger computers. It has 64 control characters, a SPACE (character 
 64) and upper and lower case letters, digits, punctuation etc. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Since 
 EBCDIC uses 8 bits it fits exactly in a byte, although in its basic form 
 many of the 256 values are not used.</p>

<p>&nbsp;</p>

<p>There are various extensions to EBCDIC to include national language 
 characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->There 
 are even double-byte extensions for certain Asian languages (Chinese etc).</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">International Character Sets</p>

<p>&nbsp;</p>

<p>The problem with ASCII (and EBCDIC) is that it only supports the English 
 alphabet and punctuation. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Accented 
 letters from other languages can sometimes be simulated using an English 
 letter followed by backspace and then another character such as the grave 
 (`), apostrophe (') etc, but this has many drawbacks such as the limitations 
 of the devices used to display the text. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->It 
 was obvious that ASCII needed to be extended to handle other languages 
 and several systems were invented. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(Similarly, 
 various extensions to EBCDIC have made use of its unassigned values.) 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}--></p>

<p>&nbsp;</p>

<p>A simple extension is the ANSI character set which extends ASCII to 
 include characters from several western European languages. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 uses the 8th bit in a byte for up to 128 extra characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 other languages (such as many eastern European ones) single-byte extensions 
 to ASCII were created which were specific to the language.</p>

<p>&nbsp;</p>

<p>For some Asian languages, though, this was still not enough and a system 
 where certain bytes were used as &quot;lead-in&quot; bytes gave access 
 to thousands of characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->These 
 are referred to as DBCS's (double byte character sets) although not all 
 characters require 2 bytes.</p>

<p>&nbsp;</p>

<p>To allow MSDOS to be used in any language Microsoft developed a system 
 of &quot;code pages&quot; specific for each language (but all are a superset 
 of ASCII). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->These 
 include DBCS code pages for Asian languages. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Despite 
 the advent of Unicode this is still how the Windows 9X family supports 
 different languages.</p>

<p>&nbsp;</p>

<p>The advantage of code pages is that it is easier to change software 
 designed only to work with ASCII to work with different code pages (even 
 DBCS code pages if only the single-byte characters are used). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 there are even greater drawbacks which is why Unicode was invented.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">Unicode</p>

<p>&nbsp;</p>

<p>An obvious drawback of using code pages is that you have to know what 
 code page was used to create the text in order to be able to read it. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->You also 
 cannot mix text from different languages (except English since all code 
 pages support ASCII). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->A 
 particular disadvantage of DBCS code pages is that it makes many software 
 tasks that work with text more difficult, as characters are not all the 
 same length (being either one or two bytes).</p>

<p>&nbsp;</p>

<p>Unicode is a character set that uses 16 bits (2 bytes) to encode all 
 the characters of the common languages of the world. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Unicode 
 is still, in a way, a superset of ASCII since the first 128 values are 
 the same as ASCII (but with the high bits zero).</p>

<p>&nbsp;</p>

<p>The major drawback of Unicode is that a lot of software that was written 
 assuming characters were storeable in a byte has to be rewritten to handle 
 it. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Fortunately, 
 Unicode is the &quot;native&quot; character set of Windows NT family (including 
 2000, XP, Vista) and most new software is being written to use it.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Next topic:</span> <a HREF="Encoding.htm">Encoding 
 Binary Data</a></p>

<p>&nbsp;</p>

</body>

</html>
