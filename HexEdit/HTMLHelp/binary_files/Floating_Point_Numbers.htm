<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Floating Point Numbers</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=date content="08 4, 2002 1:05:55 AM">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=1317>
<meta name=layout-width content=1220>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\Hexedit.css">



</head>

<!--(Body)==========================================================-->


<body>

<h2><font style="font-family: Arial;"
			face=Arial>Floating Point Numbers</font></h2>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Floating point numbers basically represent numbers using scientific 
 notation. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->That 
 is, they use a base number (called the mantissa) and an exponent. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 trades some accuracy for an increased range of values. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->A 
 32-bit floating point type can represent very large numbers (including 
 &quot;large&quot; negative numbers) and very small numbers (ie very close 
 to zero) that a 32-bit integer cannot. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->On 
 the other hand a 32 bit floating point type cannot distinguish between 
 1,000,000,000 and 1,000,000,001.</p>

<p>&nbsp;</p>

<p>Floating-point formats reserve a certain number of bits for the mantissa 
 and others for the exponent. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Sometimes 
 they are considered to have a third component -- one bit representing 
 the sign of the number -- however, I consider this to be simply the sign 
 of the mantissa. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Remember 
 that the exponent is also a signed value.</p>

<p>&nbsp;</p>

<p>The value of a floating point number is quite simply the mantissa x 
 2^exponent, although some systems may use a hexadecimal or even a decimal 
 (rather than base 2) exponent. Most micro computers nowadays use the IEEE 
 floating-point format (see below).</p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Unlike fixed-point numbers, not all patterns of bits in the bytes of 
 a floating-point number are valid. Even zero cannot be represented by 
 a normal pattern. Zero is often represented (as it is in the IEEE formats) 
 by a pattern with all bits 0 -- although a bit pattern for negative zero 
 (zero with the sign bit on) may be treated the same.</p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Seeing the right value for a particular bit pattern also depends on 
 the order of the bytes (see the discussion of byte-order in the <span 
 style="font-weight: bold;">Numeric Operations</span> section).</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Floating Point Hardware</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Early microprocessors did not have any support for floating point numbers 
 in hardware. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Later 
 (early 1980s) floating-point coprocessors were added which could work 
 in tandem with the main processor but handle floating point instructions. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For example 
 the Intel 8087 numeric-coprocessor could be optionally added to a system 
 containing the 8086 processor. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->If 
 the coprocessor was not present the floating-point instructions would 
 cause a &quot;fault&quot; which would invoke a software routine to &quot;emulate&quot; 
 the hardware. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Since 
 the software had to rely on integer arithmetic the calculations were much 
 slower than with the appropriate hardware. </p>

<p>&nbsp;</p>

<p>Larger mainframe computers have had floating point hardware for much 
 longer. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Thankfully, 
 nowadays the processors in most computers have floating point instructions. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->These instructions 
 usually include more than just arithmetic operations (addition, multiplication 
 etc) but transcendental functions (sine, arctan etc) and most of the sort 
 of operations you find on a scientific calculator. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 format that most microprocessors use for storing floating-point number 
 is the IEEE 754 standard.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">IEEE Floating Point Numbers</p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>The IEEE 754 standard for floating points numbers is implemented in 
 Intel processors on Windows machines. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->It 
 is also used by Motorola processors (used in Macintosh and Amiga computers) 
 and recent new processors (used in UNIX workstations and other systems).</p>

<p>&nbsp;</p>

<p>A 32-bit IEEE number has a sign bit followed by 8 exponent bits followed 
 by 23 mantissa bits.</p>

<p>&nbsp;</p>

<p>IEEE numbers are normally stored in normalised form (with the exceptions 
 noted below). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 means the mantissa always has a value greater than 0.5 and less than or 
 equal to 1.0. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 means the mantissa's topmost bit is one. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Hence 
 the leading mantissa bit is not stored but implicitly defined to always 
 be one.</p>

<p>&nbsp;</p>

<p>The 8-bit exponent is stored in Excess-127 format which is basically 
 a 2's complement number with the sign bit flipped. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->See 
 the Numbers section above for an explanation of Excess-127. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 exponents where all bits are zeroes or all bits are ones are reserved 
 for special values:</p>

<ul style="list-style: disc;"
	type=disc>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all zeroes 
 and mantissa is all zeroes gives a value of zero</p></li>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all zeroes 
 and mantissa is all zeroes but sign bit is one gives a value of -ve zero</p></li>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all zeroes 
 but mantissa is not zero is a denormalised value (see below)</p></li>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all ones 
 and mantissa is all zeroes gives a value of infinity</p></li>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all ones 
 and mantissa is all zeroes but sign bit is one gives a value of -ve infinity</p></li>
	
	<li class=kadov-p><p style="text-indent: 40px;">exponent is all ones 
 and mantissa is not zero denotes an invalid number (NaN)</p></li>
</ul>

<p>Although there are distinct +ve and -ve zeroes they compare as equal 
 and are treated the same in all operations.</p>

<p>&nbsp;</p>

<p>Denormalised numbers are numbers very close to zero. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->They 
 represent numbers closer to zero than the smallest (ie closest to zero) 
 normalised number. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In 
 this case the implicit leading mantissa bit is zero, hence there is a 
 loss of significant digits. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Some 
 operations that would otherwise produce zero can thus produce a result 
 that may be more useful, albeit with reduced accuracy.</p>

<p>&nbsp;</p>

<p>NaNs (which stands for &quot;not a number&quot;) are often caused by 
 uninitialised values (ie random bit patterns) but NaNs can sometimes be 
 generated by invalid operations.</p>

<p>&nbsp;</p>

<p>Apart from the 32-bit format there are also a 64-bit an 80-bit and a 
 128-bit format which have a larger range and a much larger number of significant 
 digits than a 32-bit number. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 64-bit format has an 11 bit exponent (in Excess-1023 format) and a 52 
 bit mantissa. Apart from this it works exactly the same as the 32-bit 
 format.</p>

<p>&nbsp;</p>

<p>The 80-bit and 128-bit format are less often used. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 80-bit format is supported by Intel processors, but is typically only 
 used for intermediate values to avoid loss of accuracy.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;"><span>IBM Floating Point Numbers</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>This numeric format is used in IBM mainframe and mini-computers and 
 in many binary file formats.</p>

<p>&nbsp;</p>

<p>The 32-bit format has a sign bit and a seven-bit exponent in the most 
 significant byte (the left-most byte since these numbers are usually stored 
 big-endian). <!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 exponent is a Excess-64 hexadecimal exponent which is equivalent to a 
 nine bit binary exponent (since 16^128 = 2^512). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(See 
 the Numbers section above for an explanation of Excess-X signed numbers.)</p>

<p>&nbsp;</p>

<p>The remaining 24 bits are the mantissa. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Since 
 the exponent is hexadecimal a normalised mantissa varies from any value 
 greater than 0.0625 (1/16) to less than or equal to 1.0, but non-normalised 
 values are allowed (hence there is no implicit leading mantissa bit as 
 in IEEE).</p>

<p>&nbsp;</p>

<p>There is also a 64-bit format that is the same except for an extra 32 
 significant bits in the mantissa (giving a total of 56). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Since 
 big-endian byte order is normally used this means a 64 bit values can 
 just be treated as a 32 bit value.</p>

<p>&nbsp;</p>

<p>There is also a 128 bit format but this is simply two consecutive 64 
 bit values which are simply added together. The 2<span style="vertical-align: super;">nd</span> 
 of the pair of values has an exponent which is always 14 less than the 
 exponent in the 1<span style="vertical-align: super;">st</span> value 
 which corresponds to 56 mantissa bits (16^14 = 2^56). Hence this format 
 has the same range of exponents as the 64 bit (and 32 bit) format but 
 doubles the significant digits of the mantissa.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Next topic:</span> <a HREF="Date_and_Time_Formats.htm">Date 
 and Time Formats</a></p>

<p>&nbsp;</p>

</body>

</html>
