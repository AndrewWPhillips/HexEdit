<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Error Detection</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=date content="08 27, 2002 9:00:15 PM">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=1571>
<meta name=layout-width content=867>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\Hexedit.css">



</head>

<!--(Body)==========================================================-->


<body>

<h2><font style="font-family: Arial;"
			face=Arial>Error Detection and Correction</font></h2>

<p>&nbsp;</p>

<p>When binary data is transmitted or stored it is necessary to ensure 
 that nothing has changed in the process.</p>

<p>&nbsp;</p>

<p>As data travels along a cable it can become corrupted due to noise or 
 other factors related to the physical medium. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Whenever 
 a cable is used, whether we are talking about the Internet or simply connecting 
 internal components inside your computer, there is usually some form of 
 error detection.</p>

<p>&nbsp;</p>

<p>When data is stored, the medium can deteriorate or become corrupted. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For example, 
 magnetic media such as disks and tapes are susceptible to corruption from 
 magnetic fields. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Even 
 the RAM in your computer probably now has error detection to make sure 
 the processor gets back the same byte(s) that it wrote to it.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;"><span style="font-weight: bold;">Parity</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Many communications systems use a parity bit. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In 
 this system, each unit of data (usually a byte) is accompanied by an extra 
 bit that is the sum (or XOR) of the bits of the byte. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->When 
 the byte is received the bit is checked to make sure that none of the 
 other bits have changed. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 if 2 bits change then this will not be detected.</p>

<p>&nbsp;</p>

<p>Parity can be odd or even, depending on whether the bit generated is 
 0 or 1, for a particular byte. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Odd 
 parity means all the bits including the parity bit add to one, even means 
 they add to zero. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Parity 
 is really just a single bit checksum (see below) that is done for every 
 byte.</p>

<p>&nbsp;</p>

<p>Many communication protocols, like RS232 (uses on the serial port of 
 your computer that can talk to modems, printers etc), and SCSI (used to 
 talk to hard disks, tape drives, printers etc), can use parity.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">Checksums</p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>Occasionally the word &quot;checksum&quot; is used to refer to any type 
 of error-checking including CRCs. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->More 
 commonly a checksum is just the value generated by performing repeated 
 addition on the data. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example a 16-bit checksum is found by adding all the words of the data 
 together (discarding any carry). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 value is then transmitted or stored with the data so it can be checked 
 when received or retrieved.</p>

<p>&nbsp;</p>

<p>Another way of storing the checksum is to simply use the value that 
 when added to all the data values gives a value of zero. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 is obtained by just adding all the values together (as above) then negating 
 the result (2's complement).</p>

<p>&nbsp;</p>

<p>A similar but less common &quot;checksum&quot; is obtained by XORing 
 all the values together rather than adding them.</p>

<p>&nbsp;</p>

<p>A problem with checksums is that it is very easy for multiple errors 
 to be compensating. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Checksums 
 are only useful where errors are unlikely and when they do occur they 
 are only minor. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, checksums are not a good idea for transmission protocols since 
 noise on a transmission cable is likely to change many of the data bits.</p>

<p>&nbsp;</p>

<p>Of course, a 32-bit checksum is better than a 16-bit one because there 
 are 65536 times as many values, so a few random changes are much less 
 likely to generate the same checksum <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 any checksum will fail if the same bit in consecutive bytes is flipped. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For greater 
 safety use of a CRC is preferred.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">CRCs</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>CRCs are much better at detecting errors that checksums fail to detect. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In particular, 
 depending on the particular CRC used, they are guaranteed to find multiple 
 bit errors and are good at detecting bursts of noise on a transmission 
 line. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 this reason they are used in any sort of transmission where there is good 
 chance of errors. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->They 
 are also generally used for storage media such as disks and tape.</p>

<p>&nbsp;</p>

<p>There are a myriad of particular CRC algorithms available depending 
 on the use of different parameters and variations to the basic algorithm. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 there are two commonly in use. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->CRC-CCITT 
 is a 16-bit algorithm used in many communications standards such as SDLC. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->CRC-32 
 is a 32-bit algorithm used in Ethernet.</p>

<p>&nbsp;</p>

<p>CRC-32 is also used in zip files to detect corruption. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(This 
 is very useful as these files often become corrupted during storage or 
 transmission, despite all the other error-detection that is going on.) 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->You can 
 normally see the calculated CRC of each file in the directory of a zip 
 file. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, in WinZip open the Configuration dialog (Options/Configuration) 
 then in the View page make sure the CRC column is on. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 CRC in a zip file should match a CRC-32 of the same file done in HexEdit.</p>

<p>&nbsp;</p>

<p>Of course, a 32 bit CRC is much better than a 16 bit one. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 a block of data of more than a few Kbytes use CRC-32 in preference to 
 CRC-CCITT.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Error Correction</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>When transmitting a block of data it is usually sufficient to just check 
 each block and if an error is detected have the block retransmitted. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 in many cases it is desirable or even essential that errors are not just 
 detected but are corrected. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->A 
 transmission system where the receiver(s) cannot inform the sender that 
 there has been an error requires error correction. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, a one-way communications system, or message broadcast to a large 
 number of receivers.</p>

<p>&nbsp;</p>

<p>For poor transmission media it may also be preferable to use error correction 
 as large numbers of retransmissions may be expensive or otherwise undesireable. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Error correction 
 is also useful in storage systems where if the data is corrupted it is 
 not possible to get back the original value. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, error correcting memory is becoming very common in computers.</p>

<p>&nbsp;</p>

<p>Error-correction algorithms can correct simple errors while still detecting 
 gross errors. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->HexEdit 
 does not currently implement any of these algorithms.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Message Digests</span></p>

<p style="margin-top: 0; margin-bottom: 0;">&nbsp;</p>

<p>CRCs are good for detecting random errors and even many types of structured 
 errors, however, they cannot protect against deliberate changes. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 this you need to use a message digest, also called a cryptographic checksum 
 or one-way hash function.</p>

<p>&nbsp;</p>

<p>A message digest is a number generated from data, where it is computationally 
 infeasible to find another set of data that generates the same number. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->It is called 
 one-way because you can generate the message digest from the data, but 
 given a particular message-digest it is infeasible to perform the reverse 
 operation (ie, finding a set of data that has that message digest).</p>

<p>&nbsp;</p>

<p>Obviously, there are multiple data sets that will generate the same 
 message digest. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However, 
 because of the algorithm and that the message digest is such a large number, 
 it would take a very long time, using a very fast computer to find a set 
 of data that has a particular message digest.</p>

<p>&nbsp;</p>

<p>Message digest values currently should be at least 128 bits (16 bytes). 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Using a 
 smaller value would be susceptible to brute-force attacks where random 
 data is used to search through the domain of all possible values. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(Of 
 course, just because a message digest result is 128 bits does not mean 
 the algorithm is necessarily good.)</p>

<p>&nbsp;</p>

<p>HexEdit now supports the MD5 message digest algorithm. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 is often used on the Internet to verify that downloaded files have not 
 been tampered with.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Next topic:</span> <a HREF="Binary_Files.htm">Binary 
 Files</a></p>

<p>&nbsp;</p>

</body>

</html>
